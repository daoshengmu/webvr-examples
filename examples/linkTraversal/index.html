<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  </head>
</html>
<style>
body {
    color: #808080;
    font-family:Monospace;
    font-size: 13px;
    /* text-align:center; */
    background-color: #fff;
    margin: 0px;
    overflow: hidden;
}
canvas {
  position: absolute;
  top: 0;
}
</style>
<script>
WebVRConfig = {
  MOUSE_KEYBOARD_CONTROLS_DISABLED: false,
  BUFFER_SCALE: 1.0,
};

document.addEventListener('touchmove', function(e) {
  e.preventDefault();
});
</script>
<script src="../../node_modules/three/build/three.js"></script>
<script src="../../node_modules/three/examples/js/effects/VREffect.js"></script>
<script src="../../node_modules/webvr-polyfill/build/webvr-polyfill.js"></script>
<script src="../../node_modules/three/examples/js/controls/VRControls.js"></script>
<script src="../../node_modules/webvr-ui/build/webvr-ui.js"></script>
<script>
    var camera, scene, renderer;
    var texture_placeholder,
    vrControls, vrEffect, vrDisplay, enterVR;
    isUserInteracting = false,
    onMouseDownMouseX = 0, onMouseDownMouseY = 0,
    lon = 0, onMouseDownLon = 0,
    lat = 0, onMouseDownLat = 0,
    phi = 0, theta = 0,
    distance = 500,
    onPointerDownPointerX = 0,
    onPointerDownPointerY = 0,
    onPointerDownLon = 0,
    onPointerDownLat = 0;
    init();
    animate();
    function init() {
        var mesh;
        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 );
        scene = new THREE.Scene();
    
        // Setup three.js WebGL renderer. Note: Antialiasing is a big performance hit.
        // Only enable it if you actually need to.
        renderer = new THREE.WebGLRenderer({antialias: false});
        renderer.setPixelRatio(Math.floor(window.devicePixelRatio));
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setClearColor( 0xffffff ); 
        document.body.appendChild(renderer.domElement);
        
        // Interactive control
        // document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        // document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        // document.addEventListener( 'mouseup', onDocumentMouseUp, false );
        // document.addEventListener( 'wheel', onDocumentMouseWheel, false );
        //
        window.addEventListener( 'resize', onWindowResize);
        window.addEventListener('vrdisplaypresentchange', onVRDisplayPresentChange);
        // Load video and play
        // var video = document.createElement( 'video' );
        // video.width = 640;
        // video.height = 360;
        // video.loop = true;
        // video.muted = true;
        // video.src = "resource/pano.webm";
        // video.setAttribute( 'webkit-playsinline', 'webkit-playsinline' );
        // video.play();

        // Create a sphere geometry and video material for playing
        // video in WebGL
        // var geometry = new THREE.SphereBufferGeometry( 100, 100, 100 );
        // geometry.scale( 1, 1, 1 );
        // var material = new THREE.MeshBasicMaterial( { color : "#ff0000" } );
        // mesh = new THREE.Mesh( geometry, material );
        // scene.add( mesh );
        // Create 3D objects.
        var geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        var material = new THREE.MeshNormalMaterial();
        var cube = new THREE.Mesh(geometry, material);
        // Position cube mesh
        cube.position.z = -1;
        // Add cube mesh to your three.js scene
        scene.add(cube);

        // Initialize VR
        // Apply VR headset positional data to camera.
        vrControls = new THREE.VRControls(camera);
        vrEffect = new THREE.VREffect(renderer);
        vrEffect.setSize(window.innerWidth, window.innerHeight);
        var options = {}
        enterVR = new webvrui.EnterVRButton(renderer.domElement, options);
        document.body.appendChild(enterVR.domElement);

        enterVR.getVRDisplay().then((displays)=>{
            if (displays.length > 0) {
                vrDisplay = displays[0];
            }
        });
        // navigator.getVRDisplays().then(function(displays) {
        //     if (displays.length > 0) {
        //         vrDisplay = displays[0];
        //         // Kick off the render loop.
        //         //vrDisplay.requestAnimationFrame(animate);
        //     }
        // });
        //window.location.href = 'sceneA.html';
    }

    function onWindowResize() {
        vrEffect.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    }

    function onVRDisplayPresentChange() {
      console.log('onVRDisplayPresentChange');
      onWindowResize();
    }

    function onDocumentMouseDown( event ) {
        event.preventDefault();
        isUserInteracting = true;
        onPointerDownPointerX = event.clientX;
        onPointerDownPointerY = event.clientY;
        onPointerDownLon = lon;
        onPointerDownLat = lat;
    }
    function onDocumentMouseMove( event ) {
        if ( isUserInteracting === true ) {
            lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
            lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;
        }
    }
    function onDocumentMouseUp( event ) {
        isUserInteracting = false;
    }
    function onDocumentMouseWheel( event ) {
        distance += event.deltaY * 0.05;
    }
    function animate() {
       // requestAnimationFrame( animate );
        update();
    }
    function update() {
        // lat = Math.max( - 85, Math.min( 85, lat ) );
        // phi = THREE.Math.degToRad( 90 - lat );
        // theta = THREE.Math.degToRad( lon );
        // camera.position.x = distance * Math.sin( phi ) * Math.cos( theta );
        // camera.position.y = distance * Math.cos( phi );
        // camera.position.z = distance * Math.sin( phi ) * Math.sin( theta );
        // camera.lookAt( camera.target );
        /*
        // distortion
        camera.position.copy( camera.target ).negate();
        */
        vrControls.update();
       // if (enterVR.isPresenting()) {
        vrEffect.render(scene, camera);
        // } else {
        //     renderer.render( scene, camera );
        // }

        if (vrDisplay) {
            vrDisplay.requestAnimationFrame(animate);
        } else {
            window.requestAnimationFrame(animate);
        }
    }
</script>